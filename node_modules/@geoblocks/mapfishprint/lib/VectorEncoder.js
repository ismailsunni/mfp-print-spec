import { rgbArrayToHex } from "./utils.js";
import { GeoJSON as olFormatGeoJSON } from 'ol/format.js';
import { Circle as olStyleCircle, Icon as olStyleIcon } from 'ol/style.js';
import Feature from 'ol/Feature.js';
import { getUid } from 'ol';
import { asArray } from 'ol/color.js';
import { toDegrees } from 'ol/math.js';
import VectorSource from 'ol/source/Vector.js';
import { fromCircle } from 'ol/geom/Polygon.js';
import { Constants } from "./constants.js";
/** Represents the different types of printing styles. */
export const PrintStyleType = {
    LINE_STRING: 'LineString',
    POINT: 'Point',
    POLYGON: 'Polygon',
};
/**
 * Link between supported geometry and print style types.
 * Circles will be handled as polygon.
 * */
export const PrintStyleTypes_ = {
    LineString: PrintStyleType.LINE_STRING,
    Point: PrintStyleType.POINT,
    Polygon: PrintStyleType.POLYGON,
    MultiLineString: PrintStyleType.LINE_STRING,
    MultiPoint: PrintStyleType.POINT,
    MultiPolygon: PrintStyleType.POLYGON,
};
/** Key prefix to feature style prop */
const FEATURE_STYLE_PROP = '_mfp_style';
/**
 * Calculates the priority of a GeoJSON feature based on its feature type.
 * For sort functions, to let points appearing to the top.
 * @returns The priority value.
 */
const featureTypePriority_ = (feature) => {
    const geometry = feature.geometry;
    if (geometry && geometry.type === 'Point') {
        return 0;
    }
    else {
        return 1;
    }
};
/**
 * @returns A string or an array of strings into a formatted style key.
 */
const styleKey = (styles) => {
    const keys = Array.isArray(styles) ? styles.join(',') : styles;
    return `[${FEATURE_STYLE_PROP} = '${keys}']`;
};
/**
 * Convert a given OpenLayers layer to the MapFishPrint v3 format.
 * The conversion can be customized by:
 * - extending the class;
 * - passing a customizer.
 */
export default class VectorEncoder {
    layerState_;
    layer_;
    customizer_;
    geojsonFormat = new olFormatGeoJSON();
    deepIds_ = new Map();
    lastDeepId_ = 0;
    constructor(layerState, customizer) {
        this.layerState_ = layerState;
        this.layer_ = this.layerState_.layer;
        this.customizer_ = customizer;
    }
    /**
     * Encodes the vector layer into a mapfish vector layer object.
     * @returns The encoded vector layer object or null if the layer is empty.
     */
    encodeVectorLayer(resolution) {
        const source = this.layer_.getSource();
        if (!source) {
            return null; // skipping
        }
        console.assert(source instanceof VectorSource);
        const features = source.getFeaturesInExtent(this.customizer_.getPrintExtent());
        const geojsonFeatures = [];
        const mapfishStyleObject = {
            version: 2,
        };
        features.forEach((feature) => this.encodeFeature(feature, resolution, geojsonFeatures, mapfishStyleObject));
        // MapFish Print fails if there are no style rules, even if there are no
        // features either. To work around this we just ignore the layer if the
        // array of GeoJSON features is empty.
        // See https://github.com/mapfish/mapfish-print/issues/279
        if (geojsonFeatures.length <= 0) {
            return null;
        }
        // And if there are no properties except the version in the style, ignore the layer.
        if (Object.keys(mapfishStyleObject).length <= 1) {
            return null;
        }
        // Reorder features: put points last, such that they appear on top
        geojsonFeatures.sort((feature0, feature1) => {
            const priority = featureTypePriority_;
            return priority(feature1) - priority(feature0);
        });
        const geojsonFeatureCollection = {
            type: 'FeatureCollection',
            features: geojsonFeatures,
        };
        return {
            geoJson: geojsonFeatureCollection,
            opacity: this.layerState_.opacity,
            style: mapfishStyleObject,
            type: 'geojson',
            name: this.layer_.get('name'),
        };
    }
    /**
     * Encodes a feature into a GeoJSON feature based and adds it to the array of GeoJSON features.
     * Complete the mapfishStyleObject with the related styles.
     */
    encodeFeature(feature, resolution, geojsonFeatures, mapfishStyleObject) {
        let styleData = null;
        const styleFunction = feature.getStyleFunction() || this.layer_.getStyleFunction();
        if (styleFunction) {
            styleData = styleFunction(feature, resolution);
        }
        if (feature.getGeometry().getType() === 'Circle') {
            feature = this.featureCircleAsPolygon(feature);
        }
        const origGeojsonFeature = this.geojsonFormat.writeFeatureObject(feature);
        let styles = styleData !== null && !Array.isArray(styleData) ? [styleData] : styleData;
        if (!styles) {
            return;
        }
        styles = styles.filter((style) => !!style);
        if (styles.length === 0) {
            return;
        }
        console.assert(Array.isArray(styles));
        let isOriginalFeatureAdded = false;
        styles.forEach((style) => {
            // FIXME: the return of the function is very complicate and would require
            // handling more cases than we actually do
            let geometry = style.getGeometry();
            let geojsonFeature;
            if (geometry) {
                const styledFeature = feature.clone();
                styledFeature.setGeometry(geometry);
                geojsonFeature = this.geojsonFormat.writeFeatureObject(styledFeature);
                geojsonFeatures.push(geojsonFeature);
            }
            else {
                geojsonFeature = origGeojsonFeature;
                geometry = feature.getGeometry();
                // no need to encode features with no geometry
                if (!geometry) {
                    return;
                }
                if (!this.customizer_.geometryFilter(geometry)) {
                    return;
                }
                if (!isOriginalFeatureAdded) {
                    geojsonFeatures.push(geojsonFeature);
                    isOriginalFeatureAdded = true;
                }
            }
            const geometryType = geometry.getType();
            this.addVectorStyle(mapfishStyleObject, geojsonFeature, geometryType, style);
        });
    }
    /**
     * @returns The unique identifier for the given style.
     */
    getDeepStyleUid(style) {
        const todo = [style];
        let key = '';
        while (todo.length) {
            const obj = todo.pop();
            key += '_k' + getUid(obj);
            for (const [k, value] of Object.entries(obj)) {
                if (value !== null && value !== undefined) {
                    if (['number', 'string', 'boolean'].includes(typeof value)) {
                        key += `_${k}:${value}`;
                    }
                    else {
                        todo.push(value);
                    }
                }
            }
        }
        if (this.deepIds_.has(key)) {
            return this.deepIds_.get(key).toString();
        }
        const uid = ++this.lastDeepId_;
        this.deepIds_.set(key, uid);
        return uid.toString();
    }
    /**
     * Adds a vector style to the mapfishStyleObject based on the given parameters.
     */
    addVectorStyle(mapfishStyleObject, geojsonFeature, geometryType, style) {
        const styleId = this.getDeepStyleUid(style);
        const key = styleKey(styleId);
        let hasSymbolizer;
        if (key in mapfishStyleObject) {
            // do nothing if we already have a style object for this CQL rule
            hasSymbolizer = true;
        }
        else {
            const styleObject = this.encodeVectorStyle(geometryType, style);
            hasSymbolizer = styleObject && styleObject.symbolizers.length !== 0;
            if (hasSymbolizer) {
                // @ts-ignore
                mapfishStyleObject[key] = styleObject;
            }
        }
        if (hasSymbolizer) {
            if (!geojsonFeature.properties) {
                geojsonFeature.properties = {};
            }
            this.customizer_.feature(this.layerState_, geojsonFeature);
            const existingStylesIds = geojsonFeature.properties[FEATURE_STYLE_PROP];
            if (existingStylesIds) {
                // multiple styles: merge symbolizers
                const styleIds = [...existingStylesIds.split(','), styleId];
                // @ts-ignore
                mapfishStyleObject[styleKey(styleIds)] = {
                    symbolizers: [
                        // @ts-ignore
                        ...mapfishStyleObject[styleKey(existingStylesIds)].symbolizers,
                        // @ts-ignore
                        ...mapfishStyleObject[key].symbolizers,
                    ],
                };
                geojsonFeature.properties[FEATURE_STYLE_PROP] = styleIds.join(',');
            }
            else {
                geojsonFeature.properties[FEATURE_STYLE_PROP] = styleId;
            }
        }
    }
    /**
     * Encodes the vector style based on the geometry type and style.
     * @returns The encoded vector style, or null if the geometry type is unsupported.
     */
    encodeVectorStyle(geometryType, style) {
        if (!(geometryType in PrintStyleTypes_)) {
            console.warn('Unsupported geometry type: ', geometryType);
            return null;
        }
        const styleType = PrintStyleTypes_[geometryType];
        const styleObject = {
            symbolizers: [],
        };
        const fillStyle = style.getFill();
        const imageStyle = style.getImage();
        const strokeStyle = style.getStroke();
        const textStyle = style.getText();
        if (styleType === PrintStyleType.POLYGON) {
            if (fillStyle !== null) {
                this.encodeVectorStylePolygon(styleObject.symbolizers, fillStyle, strokeStyle);
            }
        }
        else if (styleType === PrintStyleType.LINE_STRING) {
            if (strokeStyle !== null) {
                this.encodeVectorStyleLine(styleObject.symbolizers, strokeStyle);
            }
        }
        else if (styleType === PrintStyleType.POINT) {
            if (imageStyle !== null) {
                this.encodeVectorStylePoint(styleObject.symbolizers, imageStyle);
            }
        }
        if (textStyle !== null) {
            this.encodeVectorStyleText(styleObject.symbolizers, textStyle);
        }
        return styleObject;
    }
    /**
     * Encodes the vector style fill for a symbolizer.
     */
    encodeVectorStyleFill(symbolizer, fillStyle) {
        let fillColor = fillStyle.getColor();
        if (fillColor === null) {
            return;
        }
        console.assert(typeof fillColor === 'string' || Array.isArray(fillColor));
        // @ts-ignore
        fillColor = asArray(fillColor);
        console.assert(Array.isArray(fillColor), 'only supporting fill colors');
        symbolizer.fillColor = rgbArrayToHex(fillColor);
        symbolizer.fillOpacity = fillColor[3];
    }
    /**
     * Encodes the vector style for a line symbolizer, using the given stroke style.
     */
    encodeVectorStyleLine(symbolizers, strokeStyle) {
        const symbolizer = {
            type: 'line',
        };
        this.encodeVectorStyleStroke(symbolizer, strokeStyle);
        this.customizer_.line(this.layerState_, symbolizer, strokeStyle);
        symbolizers.push(symbolizer);
    }
    /**
     * Encodes a vector style point.
     */
    encodeVectorStylePoint(symbolizers, imageStyle) {
        let symbolizer;
        if (imageStyle instanceof olStyleCircle) {
            symbolizer = this.encodeVectorStylePointStyleCircle(imageStyle);
        }
        else if (imageStyle instanceof olStyleIcon) {
            symbolizer = this.encodeVectorStylePointStyleIcon(imageStyle);
        }
        if (symbolizer) {
            this.customizer_.point(this.layerState_, symbolizer, imageStyle);
            symbolizers.push(symbolizer);
        }
    }
    /**
     * Encodes the vector style point style circle.
     * @returns The encoded symbolizer point.
     */
    encodeVectorStylePointStyleCircle(imageStyle) {
        const symbolizer = {
            type: 'point',
        };
        symbolizer.pointRadius = imageStyle.getRadius();
        const scale = imageStyle.getScale();
        if (scale) {
            if (Array.isArray(scale)) {
                symbolizer.pointRadius *= (scale[0] + scale[1]) / 2;
            }
            else {
                symbolizer.pointRadius *= scale;
            }
        }
        const fillStyle = imageStyle.getFill();
        if (fillStyle !== null) {
            this.encodeVectorStyleFill(symbolizer, fillStyle);
        }
        const strokeStyle = imageStyle.getStroke();
        if (strokeStyle !== null) {
            this.encodeVectorStyleStroke(symbolizer, strokeStyle);
        }
        return symbolizer;
    }
    /**
     * Encodes a Vector Style point style icon.
     * @returns The encoded symbolizer point style or undefined if imageStyle src is undefined.
     */
    encodeVectorStylePointStyleIcon(imageStyle) {
        const src = imageStyle.getSrc();
        if (src === undefined) {
            return undefined;
        }
        const symbolizer = {
            type: 'point',
            externalGraphic: src,
        };
        const opacity = imageStyle.getOpacity();
        if (opacity !== null) {
            symbolizer.graphicOpacity = opacity;
        }
        const size = imageStyle.getSize();
        if (size !== null) {
            let scale = imageStyle.getScale();
            if (Array.isArray(scale)) {
                scale = (scale[0] + scale[1]) / 2;
            }
            if (isNaN(scale)) {
                scale = 1;
            }
            const width = size[0] * scale;
            const height = size[1] * scale;
            // Note: 'graphicWidth' is misnamed as of mapfish-console.log 3.14.1, it actually sets the height
            symbolizer.graphicWidth = height;
            this.addGraphicOffset_(symbolizer, imageStyle, width, height);
        }
        let rotation = imageStyle.getRotation();
        if (isNaN(rotation)) {
            rotation = 0;
        }
        symbolizer.rotation = toDegrees(rotation);
        return symbolizer;
    }
    /**
     * Add the graphic offset to the symbolizer.
     */
    addGraphicOffset_(symbolizer, icon, width, height) {
        if (this.hasDefaultAnchor_(icon)) {
            return;
        }
        const topLeftOffset = icon.getAnchor();
        const centerXOffset = width / 2 - topLeftOffset[0];
        const centerYOffset = height / 2 - topLeftOffset[1];
        symbolizer.graphicXOffset = centerXOffset;
        symbolizer.graphicYOffset = centerYOffset;
    }
    /**
     * Checks if the provided icon has default anchor properties.
     * @returns true if the icon has default anchor properties, otherwise false.
     */
    hasDefaultAnchor_(icon) {
        // @ts-ignore
        const icon_ = icon;
        const hasDefaultCoordinates = icon_.anchor_[0] === 0.5 && icon_.anchor_[1] === 0.5;
        const hasDefaultOrigin = icon_.anchorOrigin_ === 'top-left';
        const hasDefaultXUnits = icon_.anchorXUnits_ === 'fraction';
        const hasDefaultYUnits = icon_.anchorYUnits_ === 'fraction';
        return hasDefaultCoordinates && hasDefaultOrigin && hasDefaultXUnits && hasDefaultYUnits;
    }
    /**
     * Encodes the vector style of a polygon by applying fill and stroke styles.
     */
    encodeVectorStylePolygon(symbolizers, fillStyle, strokeStyle) {
        const symbolizer = {
            type: 'polygon',
        };
        this.encodeVectorStyleFill(symbolizer, fillStyle);
        if (strokeStyle !== null) {
            this.encodeVectorStyleStroke(symbolizer, strokeStyle);
        }
        symbolizers.push(symbolizer);
    }
    /**
     * Encodes the vector style stroke properties.
     */
    encodeVectorStyleStroke(symbolizer, strokeStyle) {
        const strokeColor = strokeStyle.getColor();
        if (strokeColor !== null) {
            console.assert(typeof strokeColor === 'string' || Array.isArray(strokeColor));
            // @ts-ignore
            const strokeColorRgba = asArray(strokeColor);
            console.assert(Array.isArray(strokeColorRgba), 'only supporting stroke colors');
            symbolizer.strokeColor = rgbArrayToHex(strokeColorRgba);
            symbolizer.strokeOpacity = strokeColorRgba[3];
        }
        const strokeDashstyle = strokeStyle.getLineDash();
        if (strokeDashstyle !== null) {
            symbolizer.strokeDashstyle = strokeDashstyle.join(' ');
        }
        const strokeWidth = strokeStyle.getWidth();
        if (strokeWidth !== undefined) {
            symbolizer.strokeWidth = strokeWidth;
        }
        const strokeLineCap = strokeStyle.getLineCap();
        if (strokeLineCap) {
            symbolizer.strokeLinecap = strokeLineCap;
        }
        const strokeLineJoin = strokeStyle.getLineJoin();
        if (strokeLineJoin) {
            symbolizer.strokeLinejoin = strokeLineJoin;
        }
    }
    /**
     * Encodes vector style text.
     */
    encodeVectorStyleText(symbolizers, textStyle) {
        const label = textStyle.getText();
        if (label) {
            const symbolizer = {
                type: 'text',
                label: textStyle.getText(),
                fontFamily: textStyle.getFont() ? textStyle.getFont() : 'sans-serif',
                labelXOffset: textStyle.getOffsetX(),
                labelYOffset: textStyle.getOffsetY(),
                labelAlign: 'cm',
            };
            const fillStyle = textStyle.getFill();
            if (fillStyle !== null) {
                this.encodeVectorStyleFill(symbolizer, fillStyle);
                symbolizer.fontColor = symbolizer.fillColor;
            }
            const strokeStyle = textStyle.getStroke();
            if (strokeStyle !== null) {
                const strokeColor = strokeStyle.getColor();
                if (strokeColor) {
                    console.assert(typeof strokeColor === 'string' || Array.isArray(strokeColor));
                    // @ts-ignore
                    const strokeColorRgba = asArray(strokeColor);
                    console.assert(Array.isArray(strokeColorRgba), 'only supporting stroke colors');
                    symbolizer.haloColor = rgbArrayToHex(strokeColorRgba);
                    symbolizer.haloOpacity = strokeColorRgba[3];
                }
                const strokeWidth = strokeStyle.getWidth();
                if (strokeWidth !== undefined) {
                    symbolizer.haloRadius = strokeWidth;
                }
            }
            this.customizer_.text(this.layerState_, symbolizer, textStyle);
            symbolizers.push(symbolizer);
        }
    }
    /**
     * Converts a circle feature to a N sides polygon feature.
     * Sides are defined in Constants.CIRCLE_TO_POLYGON_SIDES.
     */
    featureCircleAsPolygon(feature) {
        return new Feature({
            ...feature.getProperties(),
            geometry: fromCircle(feature.getGeometry(), Constants.CIRCLE_TO_POLYGON_SIDES),
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVjdG9yRW5jb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9WZWN0b3JFbmNvZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDdEMsT0FBTyxFQUFDLE9BQU8sSUFBSSxlQUFlLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFeEQsT0FBTyxFQUFDLE1BQU0sSUFBSSxhQUFhLEVBQUUsSUFBSSxJQUFJLFdBQVcsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUN6RSxPQUFPLE9BQU8sTUFBTSxlQUFlLENBQUM7QUFFcEMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLElBQUksQ0FBQztBQUMxQixPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDckMsT0FBTyxZQUFZLE1BQU0scUJBQXFCLENBQUM7QUFlL0MsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQzlDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFdEMseURBQXlEO0FBQ3pELE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRztJQUM1QixXQUFXLEVBQUUsWUFBWTtJQUN6QixLQUFLLEVBQUUsT0FBTztJQUNkLE9BQU8sRUFBRSxTQUFTO0NBQ1YsQ0FBQztBQUtYOzs7S0FHSztBQUNMLE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFHO0lBQzlCLFVBQVUsRUFBRSxjQUFjLENBQUMsV0FBVztJQUN0QyxLQUFLLEVBQUUsY0FBYyxDQUFDLEtBQUs7SUFDM0IsT0FBTyxFQUFFLGNBQWMsQ0FBQyxPQUFPO0lBQy9CLGVBQWUsRUFBRSxjQUFjLENBQUMsV0FBVztJQUMzQyxVQUFVLEVBQUUsY0FBYyxDQUFDLEtBQUs7SUFDaEMsWUFBWSxFQUFFLGNBQWMsQ0FBQyxPQUFPO0NBQzVC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