import {
  BuilderGroup_default,
  ExecutorGroup_default,
  MVT_default,
  RBush,
  VERSION,
  create,
  getBottomLeft,
  getHeight,
  getWidth,
  renderFeature,
  scale2 as scale,
  toContext,
  transform2D,
  translate
} from "./chunk-M2Y7IQ63.js";

// node_modules/@geoblocks/print/lib/encodeutils.js
function createWorldToVectorContextTransform(renderExtent, width, height) {
  var tr = create();
  var originRT = getBottomLeft(renderExtent);
  var eWidth = getWidth(renderExtent);
  var eHeight = getHeight(renderExtent);
  var r1 = eWidth / eHeight;
  var r2 = width / height;
  console.assert(Math.abs(r1 / r2 - 1) < 0.02, "extent and canvas don't have same ratio: ".concat(r1, ", ").concat(r2));
  translate(tr, 0, height);
  scale(
    tr,
    width / eWidth,
    -height / eHeight
    // we multiply by -1 due to CSS coordinate system
  );
  translate(tr, -originRT[0], -originRT[1]);
  return tr;
}
function listTilesCoveringExtentAtResolution(printExtent, printResolution, tileGrid) {
  var z = tileGrid.getZForResolution(printResolution, 0.01);
  var tiles = [];
  tileGrid.forEachTileCoord(printExtent, z, function(coord) {
    var tileExtent = tileGrid.getTileCoordExtent(coord);
    tiles.push({
      coord,
      extent: tileExtent
    });
  });
  return tiles;
}

// node_modules/@geoblocks/print/lib/canvasUtils.js
var scratchOpacityCanvas;
function asOpacity(inCanvas, opacity) {
  if (opacity === 1) {
    return inCanvas;
  }
  if (!scratchOpacityCanvas) {
    scratchOpacityCanvas = document.createElement("canvas");
  }
  var outCanvas = scratchOpacityCanvas;
  outCanvas.width = inCanvas.width;
  outCanvas.height = inCanvas.height;
  var outCtx = outCanvas.getContext("2d");
  outCtx.globalAlpha = opacity;
  outCtx.drawImage(inCanvas, 0, 0);
  return outCanvas;
}

// node_modules/@geoblocks/print/lib/MVTEncoder.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var olMajorVersion = Number.parseInt(VERSION.split(".")[0]);
var PoolDownloader = (
  /** @class */
  function() {
    function PoolDownloader2() {
    }
    PoolDownloader2.prototype.fetch = function(input, init) {
      return typeof fetch !== "undefined" ? fetch(input, init) : Promise.reject("no Fetch");
    };
    return PoolDownloader2;
  }()
);
var pool = new PoolDownloader();
var mvtFormat = new MVT_default();
var MVTEncoder = (
  /** @class */
  function() {
    function MVTEncoder2() {
    }
    MVTEncoder2.prototype.drawFeaturesToContextUsingRenderAPI_ = function(featuresExtent, styleFunction, styleResolution, coordinateToPixelTransform, context, renderBuffer, declutter) {
      var pixelRatio = 1;
      var builderGroup = new BuilderGroup_default(0, featuresExtent.extent, styleResolution, pixelRatio);
      var declutterBuilderGroup;
      if (declutter && olMajorVersion <= 9) {
        declutterBuilderGroup = new BuilderGroup_default(0, featuresExtent.extent, styleResolution, pixelRatio);
      }
      function resourceLoadedListener() {
        console.log("FIXME: some resource is now available, we should regenerate the image");
      }
      var localRenderFeature = function(feature) {
        var styles;
        var sf = feature.getStyleFunction() || styleFunction;
        if (sf) {
          styles = sf(feature, styleResolution);
        }
        var loading2 = false;
        if (styles) {
          if (!Array.isArray(styles)) {
            styles = [styles];
          }
          var tolerance = 0;
          for (var _i = 0, styles_1 = styles; _i < styles_1.length; _i++) {
            var style = styles_1[_i];
            loading2 = renderFeature(builderGroup, feature, style, tolerance, resourceLoadedListener, void 0, olMajorVersion <= 9 ? declutterBuilderGroup : declutter) || loading2;
          }
        }
        return loading2;
      };
      var loading = false;
      featuresExtent.features.forEach(function(f) {
        loading = localRenderFeature(f) || loading;
      });
      if (loading) {
        console.log("FIXME: some styles are still loading");
      }
      var sourceHasOverlaps = true;
      var executorGroupInstructions = builderGroup.finish();
      var renderingExecutorGroup = new ExecutorGroup_default(featuresExtent.extent, styleResolution, pixelRatio, sourceHasOverlaps, executorGroupInstructions, renderBuffer);
      var transform = coordinateToPixelTransform;
      var viewRotation = 0;
      var snapToPixel = true;
      var scaledSize = olMajorVersion < 9 ? 1 : [context.canvas.width, context.canvas.height];
      renderingExecutorGroup.execute(
        context,
        scaledSize,
        transform,
        viewRotation,
        snapToPixel,
        void 0,
        null
        // we don't want to declutter the base layer
      );
      if (declutterBuilderGroup) {
        var declutterExecutorGroup = new ExecutorGroup_default(featuresExtent.extent, styleResolution, pixelRatio, sourceHasOverlaps, declutterBuilderGroup.finish(), renderBuffer);
        declutterExecutorGroup.execute(context, scaledSize, transform, viewRotation, snapToPixel, void 0, declutter);
      }
    };
    MVTEncoder2.prototype.drawFeaturesToContextUsingImmediateAPI_ = function(features, styleFunction, styleResolution, coordinateToPixelTransform, vectorContext) {
      var toDraw = [];
      var i = 0;
      features.forEach(function(f) {
        var styles2 = styleFunction(f, styleResolution);
        if (styles2) {
          if (!Array.isArray(styles2)) {
            toDraw.push({
              zIndex: styles2.getZIndex(),
              feature: f,
              naturalOrder: ++i,
              styleIdx: -1
            });
          } else {
            styles2.forEach(function(style2, sIdx) {
              toDraw.push({
                zIndex: style2.getZIndex(),
                feature: f,
                naturalOrder: ++i,
                styleIdx: sIdx
              });
            });
          }
        }
      });
      toDraw.sort(function(a, b) {
        var r = (a.zIndex || 0) - (b.zIndex || 0);
        return r || a.naturalOrder - b.naturalOrder;
      });
      for (var _i = 0, toDraw_1 = toDraw; _i < toDraw_1.length; _i++) {
        var item = toDraw_1[_i];
        var styles = styleFunction(item.feature, styleResolution);
        var style = item.styleIdx === -1 ? styles : styles[item.styleIdx];
        vectorContext.setStyle(style);
        var geometry = style.getGeometry();
        if (typeof geometry === "function") {
          geometry = geometry();
        }
        if (!geometry) {
          geometry = item.feature.getGeometry();
        }
        geometry = Object.assign(Object.create(Object.getPrototypeOf(geometry)), geometry);
        var inCoos = geometry["flatCoordinates_"];
        var outCoos = geometry["flatCoordinates_"] = new Array(inCoos.length);
        var stride = geometry.getStride();
        transform2D(inCoos, 0, inCoos.length, stride, coordinateToPixelTransform, outCoos);
        vectorContext.drawGeometry(geometry);
      }
    };
    MVTEncoder2.prototype.snapTileResolution = function(tileGrid, targetResolution) {
      var resolutions = tileGrid.getResolutions();
      var resolution = resolutions[resolutions.length - 2];
      for (var i = resolutions.length - 2; i >= 0; i--) {
        var r = resolutions[i];
        if (r <= targetResolution) {
          resolution = r;
        } else {
          break;
        }
      }
      return resolution;
    };
    MVTEncoder2.prototype.assertCanvasSize = function(printExtent, canvasSize) {
      var eRatio = getWidth(printExtent) / getHeight(printExtent);
      var cRatio = canvasSize[0] / canvasSize[1];
      if (Math.abs(eRatio / cRatio - 1) > 0.02) {
        var msg = "The print extent ratio ".concat(eRatio, " and the canvas ratio ").concat(cRatio, " mismatch: ").concat(Math.abs(eRatio / cRatio - 1) * 100, " %");
        throw new Error(msg);
      }
    };
    MVTEncoder2.prototype.allFullfilled = function(promises) {
      return __awaiter(this, void 0, void 0, function() {
        var settled, _i, promises_1, p;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              settled = [];
              _i = 0, promises_1 = promises;
              _a.label = 1;
            case 1:
              if (!(_i < promises_1.length))
                return [3, 4];
              p = promises_1[_i];
              return [4, p.then(function(s) {
                return settled.push(s);
              }, function() {
              })];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [2, settled];
          }
        });
      });
    };
    MVTEncoder2.prototype.fetchFeatures = function(mvtTiles, source) {
      return __awaiter(this, void 0, void 0, function() {
        var urlFunction, projection, featuresPromises;
        return __generator(this, function(_a) {
          urlFunction = source.getTileUrlFunction();
          projection = source.getProjection();
          featuresPromises = mvtTiles.map(function(t) {
            var url = urlFunction(t.coord, 1, projection);
            if (!url) {
              return Promise.reject("Could not create URL");
            }
            return pool.fetch(url).then(function(r) {
              return r.arrayBuffer();
            }).then(function(data) {
              var features = mvtFormat.readFeatures(data, {
                extent: t.extent,
                featureProjection: projection
              });
              return {
                features,
                extent: t.extent,
                url
              };
            });
          });
          return [2, this.allFullfilled(featuresPromises)];
        });
      });
    };
    MVTEncoder2.prototype.encodeMVTLayer = function(options) {
      return __awaiter(this, void 0, void 0, function() {
        var layer, outputFormat, renderBuffer, source, tileGrid, tileResolution, printExtent, mvtTiles, featuresAndExtents, canvasSize, renderTiles, styleResolution, layerStyleFunction, layerOpacity, declutter, encodedLayers;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              layer = options.layer;
              outputFormat = options.outputFormat || "png";
              renderBuffer = layer.getRenderBuffer() || 100;
              source = layer.getSource();
              tileGrid = source.getTileGrid();
              tileResolution = this.snapTileResolution(tileGrid, options.tileResolution);
              if (tileResolution !== options.tileResolution) {
                console.warn("snapped and tile resolution mismatch: ".concat(tileResolution, " != ").concat(options.tileResolution));
                options.tileResolution = tileResolution;
              }
              printExtent = options.printExtent;
              mvtTiles = listTilesCoveringExtentAtResolution(printExtent, tileResolution, tileGrid);
              return [4, this.fetchFeatures(mvtTiles, source)];
            case 1:
              featuresAndExtents = _a.sent();
              canvasSize = options.canvasSize;
              this.assertCanvasSize(printExtent, canvasSize);
              renderTiles = [
                {
                  printExtent,
                  // print extent
                  canvasSize
                }
              ];
              styleResolution = options.styleResolution || tileResolution;
              layerStyleFunction = layer.getStyleFunction();
              layerOpacity = layer.get("opacity");
              declutter = olMajorVersion < 9 ? layer.getDeclutter() ? new RBush(7) : void 0 : !!layer.getDeclutter();
              encodedLayers = renderTiles.map(function(rt) {
                return _this.renderTile(featuresAndExtents, rt.printExtent, rt.canvasSize, styleResolution, layerStyleFunction, layerOpacity, renderBuffer, declutter, outputFormat);
              });
              return [2, encodedLayers];
          }
        });
      });
    };
    MVTEncoder2.prototype.renderTile = function(featuresExtents, rtExtent, canvasSize, styleResolution, layerStyleFunction, layerOpacity, renderBuffer, declutter, outputFormat) {
      var _this = this;
      var canvas = document.createElement("canvas");
      var ctx = canvas.getContext("2d");
      console.assert(ctx, "Could not get the context ".concat(canvas.width, "x").concat(canvas.height));
      var vectorContext = toContext(ctx, {
        size: canvasSize,
        pixelRatio: 1
      });
      featuresExtents.forEach(function(ft) {
        var transform = createWorldToVectorContextTransform(rtExtent, canvas.width, canvas.height);
        if (MVTEncoder2.useImmediateAPI) {
          _this.drawFeaturesToContextUsingImmediateAPI_(ft.features, layerStyleFunction, styleResolution, transform, vectorContext);
        } else {
          _this.drawFeaturesToContextUsingRenderAPI_(ft, layerStyleFunction, styleResolution, transform, ctx, renderBuffer, declutter);
        }
      });
      var baseUrl = (layerOpacity === 1 ? canvas : asOpacity(canvas, layerOpacity)).toDataURL(outputFormat);
      return {
        extent: rtExtent,
        baseURL: baseUrl
      };
    };
    MVTEncoder2.useImmediateAPI = false;
    return MVTEncoder2;
  }()
);
var MVTEncoder_default = MVTEncoder;
export {
  MVTEncoder_default as MVTEncoder
};
//# sourceMappingURL=main-W5AAHQPT.js.map
